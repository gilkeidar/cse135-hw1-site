<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CSE 135 HW Lives!</title>
    <link rel="icon" href="/assets/favicon.ico">
    <style>
        * {
            /* padding: 0; */
            /* margin: 0; */
            /* font-family: 'Times New Roman', Times, serif; */
            /* box-sizing: border-box; */
            /* font-size: 1rem; */
        }

        /*  CSS Variable definitions */
        :root {
            /* Colors */
            --code-color: #cccccc;
            --code-bg-color: #1f1f1f;
            --section-bg-color: beige;
            --subsection-bg-color: lightblue;

            /* Font sizes */
            --h1-font-size: 3rem;
            --h2-font-size: 2rem;
            --h3-font-size: 1.5rem;
            --p-font-size: 1.2rem;
        }

        h1 {
            font-size: var(--h1-font-size);
            font-family: sans-serif;
        }
        h2 {
            font-size: var(--h2-font-size);
            font-family: sans-serif;
        }
        h3 {
            font-size: var(--h3-font-size);
        }

        p {
            margin: 0 1dvw;
            font-size: var(--p-font-size);
            max-width: 100ch;
        }

        body {
            display: flex;
            flex-direction: column;
            gap: 1dvh;
            padding: 1dvh 1dvw;
            min-height: 100dvh;
        }

        header {
            padding: 3dvh 3dvw;
            background: var(--section-bg-color);
            text-align: center;
        }

        main {
            flex: 1;
            background: var(--section-bg-color);
            padding: 1dvh 1dvw;
            display: flex;
            flex-direction: column;
            gap: 1dvh;
        }

        main > section {
            flex: 1;
            background: lightyellow;
            padding: 1dvh 1dvw;
        }
    </style>
    <script src="https://cdn.zingchart.com/zingchart.min.js" defer></script>
    <script src="https://cdn.zinggrid.com/zinggrid.min.js" defer></script>
</head>
<body>
    <header>
        <h1>Analytics Dashboard</h1>
    </header>
    <main>
        <section>
            <h2>Most Clicked Page Elements (in top 10 pages)</h2>
            <div id="click-graphset"></div>
        </section>
        <section>
            <h2>Errors Per Page</h2>
            <a href="/user_errors.html">Detailed Report on User Errors</a>
            <div id="errors-chart"></div>
            <zing-grid id="all-errors-grid" sort search pager page-size="5"
                page-size-options="1, 2, 3, 4, 5">
                <zg-caption>Site-wide logged errors</zg-caption>
                <zg-colgroup>
                    <zg-column type="text" index="Page"></zg-column>
                    <zg-column type="text" index="Type"></zg-column>
                    <zg-column type="element" type-element-tag-name="pre" index="Message"></zg-column>
                    <zg-column type="date" index="Time" type-date-format="hh:mm:ss, dddd, MMMM Do YYYY" sort-desc="true"></zg-column>
                </zg-colgroup>
            </zing-grid>
        </section>
        <section>
            <h2>JavaScript Availability By Session</h2>
            <div id="js-availability-chart"></div>
        </section>
    </main>
    <script>
        function isClickEvent(event_name) {
            const click_event_names = ["click", "contextmenu", "dblclick", 
                "mousedown"];

            for (let click_event of click_event_names) {
                if (click_event == event_name)
                    return true;
            }

            return false;
        }

        function removeIndexHTML(url_path) {
            console.log(`removeIndexHTML(${url_path})`);
            let index = url_path.indexOf("index.html");
            if (index < 0) {
                return url_path;
            }
            return url_path.substring(0, index);
        }

        function getClickElementName(element_target) {
            console.log(element_target);

            if (element_target.id.length > 0) {
                return element_target.id;
            }

            return element_target.className + element_target.nodeName;
        }

        function createClickBarChart(page, pages) {
            console.log(page);
            console.log(pages[page]);

            //  1.  Convert object pages[page] object to an array.
            let clickedElements = [];
            for (let element in pages[page]) {
                clickedElements.push({
                    name: element,
                    freq: pages[page][element]
                });
            }
            console.log(clickedElements);
            //  2.  Sort the array by frequency (non-increasing).
            clickedElements.sort((e1, e2) => e2.freq - e1.freq);
            //  3.  Create corresponding scaleX array (for element names).
            let clickedElementNames = [];
            let clickedElementFreqs = [];

            let totalClickFreq = 0;
            for (let element of clickedElements) {
                clickedElementNames.push(element.name);
                clickedElementFreqs.push(element.freq);
                totalClickFreq += element.freq;
            }

            let config = {
                type: 'bar',
                title: {
                    text: page
                },
                scaleX: {
                    label: {text: "Clicked Elements"},
                    labels: clickedElementNames
                },
                scaleY: {
                    step: 1
                },
                series: [
                    {
                        values: clickedElementFreqs,
                        text: '# element was clicked',
                        tooltip: {
                            text: "%kt clicked %vt times."
                        }
                    }
                ]
            };

            return {
                config: config,
                totalFreq: totalClickFreq
            };
        }

        function renderClickedPageElements(activity) {
            console.log("renderClickedPageElements()");
            //  NOTE: Potential optimization: Query ONLY click ActivityData
            //  events! (Maybe add a special /api/click-events?)
            
            //  Question: For each page p: What elements in p are being clicked
            //      on, and how often?
            //  To answer this question, it will likely make sense to have a bar
            //  chart per page.
            //  Each bar chart will then have the following structure:
            //      x-axis: page elements that have been clicked on at least
            //          once
            //      y-axis: for each page element, the number of times the page
            //          element was clicked on.
            //      The x-axis should be sorted so that the corresponding y-axis
            //      values are non-increasing from left to right (i.e., the most
            //      clicked elements should be on the left)
            //  This means that the bar graphs should be represented together in
            //  a graph set.
            
            //  1.  Create an object with keys being URL paths and values being
            //      objects with element fields (stringified JSON of click event
            //      targets) whose values are click frequency.
            let pages = {};
            for (let activityBurst of activity) {
                for (let activityData of activityBurst.activity) {
                    if (isClickEvent(activityData.event_name)) {
                        //  1.  Check whether the page URLpath  is a property of
                        //      the pages object.
                        //  Avoid incorrect separation of click event frequency
                        //  counts by differences between / and /index.html
                        let path = removeIndexHTML(activityData.page);

                        console.log(`Click event in path ${path}`);
                        console.log(activityData);

                        let clickTarget = activityData.event_info.target;
                        let targetString = getClickElementName(clickTarget);

                        if (path in pages) {
                            //  1.  Check whether the target is a property of
                            //      the target string.
                            if (targetString in pages[path]) {
                                pages[path][targetString]++;
                            }
                            else {
                                pages[path][targetString] = 1;
                            }
                        }
                        else {
                            //  path not in pages object.
                            //  Set it to an object with the target frequency
                            //  being 1.
                            pages[path] = {
                                [targetString]: 1
                            };
                        }
                    }
                }
            }

            console.log(pages);

            //  2.  For each page, create a bar chart.
            let pageResults = [];
            for (let page in pages) {
                console.log(`Creating click bar chart for page ${page}`);

                pageResults.push(createClickBarChart(page, pages));
            }

            //  3.  Sort page results by click frequency
            pageResults.sort((p1, p2) => p2.totalFreq - p1.totalFreq);

            console.log(pageResults);

            let graphset = [];
            for (let pageResult of pageResults) {
                graphset.push(pageResult.config);
            }

            console.log(graphset);

            let graphsetConfig = {
                layout: "2x5",
                theme: "dark",
                graphset: graphset,
            };

            zingchart.render({
                id: "click-graphset",
                data: graphsetConfig
            });
        }

        function isErrorEvent(activityData) {
            return activityData.event_name.includes("error");
        }

        function renderErrorAnalysis(activity) {
            console.log("renderErrorAnalysis()");

            //  Question: For each page p, what errors have been thrown?
            //  (Will answer this question in more detail in the report).
            //  Simple answer:
            //  1.  Include a bar chart showing the number of errors that occur
            //      on each page.
            //      x-axis: pages that have logged at least one error
            //      y-axis: the number of errors logged on each page
            //      This should be sorted in non-increasing order from left to
            //      right so that the page with the most errors is the left-most
            //      bar.  
            //  2.  Include a grid for each page that had at least one error
            //      thrown that contains a listing of the error events that
            //      occurred on that page.

            //  1.  Create a pages object (key->value hashmap where key is page
            //      path and value is an object with a number of errors and an
            //      array of error events).
            let pages = {};
            
            //  2.  Iterate through ActivityData objects and note each error
            //      event as it appears.
            for (let activity_burst of activity) {
                for (let activity_data of activity_burst.activity) {
                    //  1.  Determine whether activity_data is of an error
                    //      event.
                    if (isErrorEvent(activity_data)) {
                        //  1.  Get page path
                        let page = activity_data.page;

                        //  2.  If the pages object already has this page as a
                        //      key, then log the error event and increment the
                        //      number of events in that page.
                        if (page in pages) {
                            pages[page].numErrors++;
                            pages[page].errors.push(activity_data);
                        }
                        else {
                            //  Create new page object
                            pages[page] = {
                                numErrors: 1,
                                errors: [ activity_data ]
                            };
                        }
                    }
                }
            }

            console.log("errors:");
            console.log(pages);

            //  1.  Create grid from pages object
            let gridData = [];

            //  2.  Create bar chart
            let errorPages = [];

            for (let page in pages) {
                //  Add error page to errorPages array (for bar chart)
                errorPages.push({
                    page: page,
                    numErrors: pages[page].numErrors
                });

                for (let error of pages[page].errors) {
                    //  Add error to grid
                    gridData.push({
                        "Page": error.page,
                        "Type": error.event_name,
                        "Message": JSON.stringify(error.event_info, null, 2),
                        "Time": error.time_stamp
                    });
                }
            }

            let grid = document.querySelector("#all-errors-grid");
            grid.setData(gridData);

            //  3.  Sort errorPages array by numErrors
            errorPages.sort((p1, p2) => p2.numErrors - p1.numErrors);

            let scaleX = [];
            let scaleY = [];

            for (let page of errorPages) {
                scaleX.push(page.page);
                scaleY.push(page.numErrors);
            }

            //  4.  Render bar chart
            let barConfig = {
                type: 'bar',
                title: {
                    text: "Errors Per Page",
                    fontSize: 24
                },
                scaleX: {
                    label: {text: "Pages"},
                    labels: scaleX
                },
                scaleY: {
                    step: 1
                },
                series: [
                    {
                        values: scaleY,
                        text: "# errors per page",
                        tooltip: {
                            text: "%kt had %vt errors."
                        },
                        backgroundColor: "darkred"
                    }
                ]
            };

            zingchart.render({
                id: "errors-chart",
                data: barConfig
            });
        }
        
        function renderJavaScriptAvailability(sessions) {
            console.log("renderJavaScriptAvailability()");

            //  Question: How many sessions have JavaScript turned on or off?
            //  To answer this, it will likely make sense to show a pie chart
            //  where there are two slices: one representing the proportion of
            //  sessions that have JS turned on, and one representing the
            //  proportion of sessions that have JS turned off.

            let jsAvailability = {
                haveJS: {
                    freq: 0,
                    text: "JS Available",
                    color: "green",
                    caption: "JavaScript turned on."
                },
                noJS: {
                    freq: 0,
                    text: "JS Unavailable",
                    color: "darkred",
                    caption: "JavaScript turned off."
                },
                unknown: {
                    freq: 0,
                    text: "JS Availability Unknown",
                    color: "gray",
                    caption: "unknown JavaScript availability."
                }
            };

            for (let session of sessions) {
                if ("static_data" in session 
                    && "user-allows-javascript" in session.static_data) {
                    if (session.static_data["user-allows-javascript"]) {
                        jsAvailability.haveJS.freq++;
                    }
                    else {
                        jsAvailability.noJS.freq++;
                    }
                }
                else {
                    jsAvailability.unknown.freq++;
                }
            }

            let series = [];

            for (let propertyName in jsAvailability) {
                let property = jsAvailability[propertyName];

                //  Display percent with 2 decimal places
                let percent = 
                    Math.floor((property.freq / sessions.length) * 10000) / 100;
                if (property.freq > 0) {
                    series.push({
                        text: property.text,
                        values: [property.freq / sessions.length],
                        "background-color": property.color,
                        tooltip: {
                            text: `${percent}%
                                of sessions have ${property.caption}`
                        }
                    })
                }
            }

            let pieConfig = {
                type: "pie",
                title: {
                    text: "JavaScript Availability Across Sessions",
                    fontSize: 24
                },
                legend: {
                    draggable: true
                },
                series: series
            };

            zingchart.render({
                id: "js-availability-chart",
                data: pieConfig
            });
        }

        addEventListener('load', async (e) => {
            //  1.  Query UserSessions and ActivityBurst data from the REST API
            //      endpoint.
            let response = await fetch('https://gilkeidar.com/api/user-sessions');
            let sessions = await response.json();
            
            response = await fetch('https://gilkeidar.com/api/activity-bursts');
            let activity = await response.json();

            //  2.  Render each metric's charts
            renderClickedPageElements(activity);
            renderErrorAnalysis(activity);
            renderJavaScriptAvailability(sessions);
        });
    </script>
</body>
</html>