//  collector.js script (Checkpoint 1 Version)
//  This collector.js script does the following:
//  1.  Sets up / loads a session in localStorage (including user id).
//      *   Note: This means that session information is generated on the client
//          side. Since the session information is only used for analytics, this
//          doesn't fundamentally pose a security problem, but it is limiting
//          (since data collected without this script cannot be attributed to a
//          particular session).
//          This will be changed in Checkpoint 2 forwards by using an Apache
//          server module to generate session id and user id cookies (all
//          requests to the REST endpoint will include these cookies and so the
//          REST endpoint will be able to "stamp" all incoming data with the
//          particular user and session to which it is attributed).
//  2.  Collects static and performance data once per session and sends it to
//      the mock REST endpoint at /json/user-sessions.
//  3.  Continuously collects activity (i.e., event) data and sends it in
//      batches every ACTIVITY_COLLECTION_PERIOD milliseconds to the mock REST
//      endpoint at /json/activity-bursts.

/*  Constants  */

/**
 * Length of user and session IDs, in characters (as generated by generateID();
 * this will be replaced with server cookies in Checkpoint 2 onwards)
 */
const ID_LENGTH = 20;

/**
 * Number of letters in the English alphabet.
 */
const NUM_LETTERS = 26;

/**
 * Number of digits (in base 10).
 */
const NUM_DIGITS = 10;

/**
 * Number of possible characters in an ID generated by generateID().
 */
const ID_ALPHABET_SIZE = NUM_LETTERS * 2 + NUM_DIGITS;

/**
 * Session time length (30 minutes in ms)
 * (30 min * (60 sec / min) * (1000 ms / sec))
 */
const MAX_SESSION_TIME = 30 * 60 * 1000;

/**
 * Activity collection period interval (in ms)
 * (10 sec * (1000 ms / sec))
 */
const ACTIVITY_COLLECTION_PERIOD = 10 * 1000;

/**
 * localStorage key name for storing a user id.
 */
const ls_USER_ID = "user_id";

/**
 * localStorage key name for storing a session id.
 */
const ls_SESSION_ID = "session_id";

/**
 * localStorage key name for storing a stringified JSON object representing the
 * user session (i.e., a stringified UserSession object).
 */
const ls_USER_SESSION = "user_session";

/**
 * localStorage key name for storing a stringified JSON object representing the
 * last unsent activity burst (i.e., a stringified ActivityBurst object).
 */
const ls_ACTIVITY_BURST = "activity_burst";

/**
 * URL of mock REST endpoint to POST UserSession data to (once per session).
 */
const USER_SESSION_ENDPOINT = "https://gilkeidar.com/json/user-sessions";

/**
 * URL of mock REST endpoint to POST ActivityBurst data to (once per
 * ACTIVITY_COLLECTION_PERIOD).
 */
const ACTIVITY_BURST_ENDPOINT = "https://gilkeidar.com/json/activity-bursts";

/*  Class Definitions   */

/**
 * Class that stores information for a single continuous activity event (e.g., 
 * mouse click, key press, etc).
 */
class ActivityData {
    /**
     * ActivityData constructor.
     * @param {String} event_name Name of the continuous activity event.
     * @param {Number} time_stamp Timestamp of when the event occurred (using ms
     * since the Unix epoch time, generated with Date.now())
     * @param {Object} event_info Object containing the relevant event 
     * information
     */
    constructor(event_name, time_stamp, event_info) {
        console.log("Creating ActivityData object.");
        this.event_name = event_name;
        this.time_stamp = time_stamp;
        this.event_info = event_info;
    }
}

/**
 * Class that stores an array of ActivityData objects collected in a single
 * ACTIVITY_COLLECTION_PERIOD.
 */
class ActivityBurst {
    /**
     * Static ID to mark each ActivityBurst object with its own ID.
     * TODO: REMOVE! This only works if you have one client that runs once!
     * Otherwise, other ids will be reset. Just leave it to the endpoint to
     * identify.
     */
    static id = 1;
    /**
     * Maximum length of an ActivityBurst's ActivityData array. (Maximum number
     * of events that can be collected in a single ACTIVITY_COLLECTION_PERIOD).
     */
    static MAX_ACTIVITY_BURST_SIZE = 10000;

    /**
     * ActivityBurst constructor. Marks this ActivityBurst with the current user
     * session ID and initializes the ActivityData array.
     * @note This method assumes that the user session ID has already been set
     * up in localStorage.
     */
    constructor() {
        constructor.log("Creating ActivityBurst object.");
        //  Mark this ActivityData object with its own ID.
        this.id = ActivityData.id++;

        //  Mark the ActivityBurst with the session ID. (Requires session to be
        //  setup).
        this.session_id = localStorage.getItem(ls_SESSION_ID);
        this.burst_start = 0;
        this.burst_end = 0;
        this.activity = [];
    }

    /**
     * Attempts to append the given ActivityData object to this ActivityBurst's
     * ActivityData array if the array isn't full and if the given ActivityData
     * object is not null.
     * @param {ActivityData} activityData ActivityData object to log in the
     * current ACTIVITY_COLLECTION_PERIOD.
     * @throws an Error if activityData is null.
     */
    logActivityData(activityData) {
        console.log("logActivityData()");
        if (!activityData) {
            //  Throw error.
            throw new Error("Attempting to log null ActivityData object!");
        }

        if (this.activity.length == 0) {
            //  ActivityData array is empty; set burst_start timestamp to the
            //  given activityData's timestamp.
            this.burst_start = activityData.time_stamp;
        }

        //  Only push ActivityData to array if it fits.
        if (this.activity.length < ActivityBurst.MAX_ACTIVITY_BURST_SIZE) {
            this.activity.push(activityData);

            //  Set burst_end timestamp to the given activityData's timestamp.
            this.burst_end = activityData.time_stamp;
        }
    }
}

/**
 * Class that stores static data collected about the current user session.
 */
class StaticData {
    /**
     * StaticData constructor. Fills instance properties with static data
     * collected about the current user session.
     */
    constructor() {
        console.log("Creating StaticData object.");

        //  1.  Get the user agent string
        this["user-agent"] = window.navigator.userAgent;

        //  2.  Get the user's language
        this["user-language"] = window.navigator.language;

        //  3.  Get whether the user accepts cookies
        this["user-accepts-cookies"] = window.navigator.cookieEnabled;

        //  4.  Get whether the user accepts JavaScript (trivially true if this
        //      script is running)
        this["user-allows-javascript"] = true;

        //  5.  Get whether the user allows images
        this["user-allows-images"] = !!document.createElement("img");

        //  6.  Get whether the user allows CSS
        //      (Done by testing whether a very basic property is supported)
        this["user-allows-css"] = CSS.supports("color", "red");

        //  7.  Get the user's screen dimensions
        this["user-screen-dimensions"] = {
            width: window.screen.width,
            height: window.screen.height
        };

        //  8.  Get the user's window dimensions
        this["user-window-dimensions"] = {
            width: window.innerWidth,
            height: window.innerHeight
        };

        //  9.  Get the user's network connection type
        this["user-network-connection-type"] =
            window.navigator.connection.effectiveType;
    }
}

/**
 * Class that stores performance data collected about the current user session.
 */
class PerformanceData {
    /**
     * PerformanceData constructor. Fills instance properties with performance
     * data collected about the current user session.
     */
    constructor() {
        console.log("Creating PerformanceData object.");

        let loadStart = window.performance.timing.loadEventStart;
        let loadEnd = window.performance.timing.loadEventEnd;
        let loadTime = loadEnd - loadStart;

        //  1.  Get the timing object
        //      Note: window.performance.timing is deprecated.
        this["timing-object"] = window.performance.timing;
        this["page-load-start"] = loadStart;
        this["page-load-end"] = loadEnd;
        this["page-load-time"] = loadTime;
    }
}

/**
 * Class that stores static and performance data about the current user session.
 * Sent once per session to the USER_SESSION_ENDPOINT.
 */
class UserSession {
    /**
     * UserSession constructor. Creates StaticData and PerformanceData objects.
     * @param {String} id ID of the current user session.
     * @param {String} user_id ID of the current user.
     */
    constructor(id, user_id) {
        console.log("Creating UserSession object.");
        this.id = id;
        this.user_id = user_id;
        this.static_data = new StaticData();
        this.performance_data = new PerformanceData();
    }
}

/**
 * Class to track user idleness.
 */
class TrackIdle {
    /**
     * TrackIdle construtcor.
     * @param {Number} minIdleTime minimum idle time in milliseconds.
     */
    constructor(minIdleTime) {
        this.minIdleTime = minIdleTime;
        this.resetIdleTracking();
    }

    resetIdleTracking() {
        this.last_activity_time = Date.now();
        this.isIdle = false;
        setTimeout(() => {
            this.idleStartEventHandler();
        }, this.minIdleTime);
    }

    idleStartEventHandler() {
        if (!this.isIdle 
            && Date.now() - this.last_activity_time > this.minIdleTime) {
            console.log("idlestart event fired.");
            this.isIdle = true;

            //  TODO: Call activityEventHandler to log this event.
        }
    }
}

class ActivityEventLogger {
    constructor() {
        //  Initialize activity event logging.
        //  1.  Assign event handlers for every continuous activity event we
        //      want to track.
        //  2. 
    }
}

/*  Global Variables    */

/**
 * ActivityBurst stored globally in memory (for current 
 * ACTIVITY_COLLECTION_PERIOD).
 * ActivityData collected during this period is written to the activity_burst;
 * at the end of the period, it is written to localStorage and the script
 * attempts to send it to the ACTIVITY_BURST_ENDPOINT.
 */
let activity_burst = new ActivityBurst();


/*  Function Definitions    */

/*  Event Handlers  */

/*  Continuous Activity Event Handlers  */

/*  Load Event + Setting up activity event handlers */