//  collector.js script (Checkpoint 1 Version)
//  This collector.js script does the following:
//  1.  Sets up / loads a session in localStorage (including user id).
//      *   Note: This means that session information is generated on the client
//          side. Since the session information is only used for analytics, this
//          doesn't fundamentally pose a security problem, but it is limiting
//          (since data collected without this script cannot be attributed to a
//          particular session).
//          This will be changed in Checkpoint 2 forwards by using an Apache
//          server module to generate session id and user id cookies (all
//          requests to the REST endpoint will include these cookies and so the
//          REST endpoint will be able to "stamp" all incoming data with the
//          particular user and session to which it is attributed).
//  2.  Collects static and performance data once per session and sends it to
//      the mock REST endpoint at /json/user-sessions.
//  3.  Continuously collects activity (i.e., event) data and sends it in
//      batches every ACTIVITY_COLLECTION_PERIOD milliseconds to the mock REST
//      endpoint at /json/activity-bursts.

/*  Constants  */

/**
 * Length of user and session IDs, in characters (as generated by generateID();
 * this will be replaced with server cookies in Checkpoint 2 onwards)
 */
const ID_LENGTH = 20;

/**
 * Number of letters in the English alphabet.
 */
const NUM_LETTERS = 26;

/**
 * Number of digits (in base 10).
 */
const NUM_DIGITS = 10;

/**
 * Number of possible characters in an ID generated by generateID().
 */
const ID_ALPHABET_SIZE = NUM_LETTERS * 2 + NUM_DIGITS;

/**
 * Session time length (30 minutes in ms)
 * (30 min * (60 sec / min) * (1000 ms / sec))
 */
const MAX_SESSION_TIME = 30 * 60 * 1000;

/**
 * Activity collection period interval (in ms)
 * (10 sec * (1000 ms / sec))
 */
const ACTIVITY_COLLECTION_PERIOD = 10 * 1000;

/**
 * Minimum time the user has to be idle in order for the "idlestart" event to
 * fire (in ms)
 * (2 sec * (1000 ms / sec))
 */
const MIN_IDLE_TIME = 2 * 1000;

/**
 * localStorage key name for storing a user id.
 */
const ls_USER_ID = "user_id";

/**
 * localStorage key name for storing a session id.
 */
const ls_SESSION_ID = "session_id";

/**
 * localStorage key name for storing a stringified JSON object representing the
 * user session (i.e., a stringified UserSession object).
 */
const ls_USER_SESSION = "user_session";

/**
 * localStorage key name for storing a stringified JSON object representing the
 * last unsent activity burst (i.e., a stringified ActivityBurst object).
 */
const ls_ACTIVITY_BURST = "activity_burst";

/**
 * localStorage key name for the timestamp of the start of the user session.
 */
const ls_SESSION_START = "session_start";

/**
 * URL of mock REST endpoint to POST UserSession data to (once per session).
 */
const USER_SESSION_ENDPOINT = "https://gilkeidar.com/json/user-sessions";

/**
 * URL of mock REST endpoint to POST ActivityBurst data to (once per
 * ACTIVITY_COLLECTION_PERIOD).
 */
const ACTIVITY_BURST_ENDPOINT = "https://gilkeidar.com/json/activity-bursts";

/**
 * Class that stores static data collected about the current user session.
 */
class StaticData {
    /**
     * StaticData constructor. Fills instance properties with static data
     * collected about the current user session.
     */
    constructor() {
        console.log("Creating StaticData object.");

        //  1.  Get the user agent string
        this["user-agent"] = window.navigator.userAgent;

        //  2.  Get the user's language
        this["user-language"] = window.navigator.language;

        //  3.  Get whether the user accepts cookies
        this["user-accepts-cookies"] = window.navigator.cookieEnabled;

        //  4.  Get whether the user accepts JavaScript (trivially true if this
        //      script is running)
        this["user-allows-javascript"] = true;

        //  5.  Get whether the user allows images
        this["user-allows-images"] = !!document.createElement("img");

        //  6.  Get whether the user allows CSS
        //      (Done by testing whether a very basic property is supported)
        this["user-allows-css"] = CSS.supports("color", "red");

        //  7.  Get the user's screen dimensions
        this["user-screen-dimensions"] = {
            width: window.screen.width,
            height: window.screen.height
        };

        //  8.  Get the user's window dimensions
        this["user-window-dimensions"] = {
            width: window.innerWidth,
            height: window.innerHeight
        };

        //  9.  Get the user's network connection type
        this["user-network-connection-type"] =
            window.navigator.connection.effectiveType;
    }
}

/**
 * Class that stores performance data collected about the current user session.
 */
class PerformanceData {
    /**
     * PerformanceData constructor. Fills instance properties with performance
     * data collected about the current user session.
     */
    constructor() {
        console.log("Creating PerformanceData object.");

        let loadStart = window.performance.timing.loadEventStart;
        let loadEnd = window.performance.timing.loadEventEnd;
        let loadTime = loadEnd - loadStart;

        //  1.  Get the timing object
        //      Note: window.performance.timing is deprecated.
        this["timing-object"] = window.performance.timing;
        this["page-load-start"] = loadStart;
        this["page-load-end"] = loadEnd;
        this["page-load-time"] = loadTime;
    }
}

/**
 * Class that stores static and performance data about the current user session.
 * Sent once per session to the USER_SESSION_ENDPOINT.
 */
class UserSession {
    /**
     * UserSession constructor. Creates StaticData and PerformanceData objects.
     * @param {String} id ID of the current user session.
     * @param {String} user_id ID of the current user.
     */
    constructor(id, user_id) {
        console.log("Creating UserSession object.");
        this.id = id;
        this.user_id = user_id;
        this.static_data = new StaticData();
        this.performance_data = new PerformanceData();
    }
}

/**
 * Class that stores information for a single continuous activity event (e.g., 
 * mouse click, key press, etc).
 */
class ActivityData {
    /**
     * ActivityData constructor.
     * @param {String} event_name Name of the continuous activity event.
     * @param {Number} time_stamp Timestamp of when the event occurred (using ms
     * since the Unix epoch time, generated with Date.now())
     * @param {Object} event_info Object containing the relevant event 
     * information
     */
    constructor(event_name, time_stamp, event_info) {
        console.log("Creating ActivityData object.");
        this.event_name = event_name;
        this.time_stamp = time_stamp;
        this.event_info = event_info;
    }
}

/**
 * Class that stores an array of ActivityData objects collected in a single
 * ACTIVITY_COLLECTION_PERIOD.
 */
class ActivityBurst {
    /**
     * Maximum length of an ActivityBurst's ActivityData array. (Maximum number
     * of events that can be collected in a single ACTIVITY_COLLECTION_PERIOD).
     */
    static MAX_ACTIVITY_BURST_SIZE = 10000;

     /**
     * ActivityBurst constructor. Marks this ActivityBurst with the current user
     * session ID and initializes the ActivityData array.
     * @note This method assumes that the user session ID has already been set
     * up in localStorage.
     */
    constructor() {
        console.log("Creating ActivityBurst object.");

        //  Mark the ActivityBurst with the session ID. (Requires session to be
        //  setup).
        this.session_id = localStorage.getItem(ls_SESSION_ID);
        this.burst_start = 0;
        this.burst_end = 0;
        this.activity = [];
    }

    /**
     * Attempts to append the given ActivityData object to this ActivityBurst's
     * ActivityData array if the array isn't full and if the given ActivityData
     * object is not null.
     * @param {ActivityData} activityData ActivityData object to log in the
     * current ACTIVITY_COLLECTION_PERIOD.
     * @throws an Error if activityData is null.
     */
    addActivityData(activityData) {
        console.log("logActivityData()");
        if (!activityData) {
            //  Throw error.
            throw new Error("Attempting to log null ActivityData object!");
        }

        if (this.activity.length == 0) {
            //  ActivityData array is empty; set burst_start timestamp to the
            //  given activityData's timestamp.
            this.burst_start = activityData.time_stamp;
        }

        //  Only push ActivityData to array if it fits.
        if (this.activity.length < ActivityBurst.MAX_ACTIVITY_BURST_SIZE) {
            this.activity.push(activityData);

            //  Set burst_end timestamp to the given activityData's timestamp.
            this.burst_end = activityData.time_stamp;
        }
    }
}

class ActivityEventLogger {
    static activity_events = [
        //  Error events
        "error",
        //  Mouse events
        "click", "contextmenu", "dblclick", "mousedown", "mouseup", 
        "mouseenter", "mouseleave", "mouseout",
        // "mouseenter", "mouseleave", "mouseout", "mouseover", "mousemove",
        // "scroll",
        // //  Keyboard events
        // "keydown", "keypress", "keyup",
        // //  Page Entry / Exit events
        // "visibilitychange"

        //  Custom Events (Idle start / end, console error)
        "idlestart", "idleend", "console_error"
        
    ];
    static user_activity_events = [
        //  Mouse events
        "click", "contextmenu", "dblclick", "mousedown", "mouseup", 
        "mouseenter", "mouseleave", "mouseout"
        // "mouseenter", "mouseleave", "mouseout", "mouseover", "mousemove",
        // "scroll",
        // //  Keyboard events
        // "keydown", "keypress", "keyup",
        // //  Page Entry / Exit events
        // "visibilitychange"
    ];

    constructor(set_events_and_track_idleness = true) {
        console.log("Creating ActivityEventLogger object.");

        //  Initial setup.
        //  1.  Setup activity burst.
        this.activity_burst = new ActivityBurst();

        //  2.  Assign event handler to every activity event we want to log.
        if (set_events_and_track_idleness) {
            for (let event_name of ActivityEventLogger.activity_events) {
                document.addEventListener(event_name, (e) => {
                    this.logActivityEvent(e);
                });
            }

            //  3.  Begin tracking user idleness
            this.minIdleTime = MIN_IDLE_TIME;
            this.resetIdleTracking();
        }
    }

    resetIdleTracking() {
        console.log("resetIdleTracking().");

        this.last_activity_time = Date.now();
        this.isIdle = false;
        setTimeout(() => {
            // this.idleStartEventHandler();
            this.idleStartEventTrigger();
        }, this.minIdleTime);
    }

    idleStartEventTrigger() {
        let current_time = Date.now();
        if (!this.isIdle 
            && current_time - this.last_activity_time > this.minIdleTime) {
            console.log("idlestart event fired.");
            this.isIdle = true;

            // let idle_start_event = {
            //     type: "idlestart",
            //     time_stamp: current_time
            // };
            let idle_start_event = new CustomEvent("idlestart", {
                detail: {
                    time_stamp: current_time
                }
            });

            document.dispatchEvent(idle_start_event);
        }
    }

    createIdleEndEvent() {
        let time_stamp = Date.now();

        return new CustomEvent("idleend", {
            detail: {
                time_stamp: time_stamp,
                //  Duration:
                //  last activity time is 2 seconds *before* idlestart event 
                //  fired, so idle duration (idlestart to idleend) is
                //  now - last_activity_time - 2 seconds
                duration: time_stamp - this.last_activity_time 
                    - this.minIdleTime
            }
        });
    }

    logActivityEvent(e) {
        console.log(`${e.type} event fired!`);
        console.log(e);
        //  Log activity event e.
        //  1.  If e is an event caused by user activity, update user idleness
        //      tracking (potentially firing "idleend" event).
        if (ActivityEventLogger.user_activity_events.includes(e.type)) {
            //  1.  If the user is currently idle, fire "idleend" event.
            if (this.isIdle) {
                //  1.  Set user to no longer be idle.
                this.isIdle = false;

                //  2.  Log "idleend" event.
                //      NOTE: To avoid infinite loop, "idleend" must not be
                //      included in ActivityEventLogger.user_activity_events!
                let idle_end_event = this.createIdleEndEvent();
                document.dispatchEvent(idle_end_event);
                // this.logActivityEvent(idle_end_event);
            }

            //  2.  Reset idle tracking
            this.resetIdleTracking();
        }

        //  2.  Create an ActivityData object for e.
        //      1.  Get event name.
        let event_name = e.type;

        //      2.  Get timestamp
        let event_time;

        if (["idlestart", "idleend"].includes(event_name)) {
            //  Use idleend's and idlestart's timestamp for more accurate 
            //  logging (since it's already in the Unix epoch format)
            event_time = e.detail.time_stamp;
        }
        else {
            event_time = Date.now();
        }

        //      3.  Get event info object for e.
        let event_info = ActivityEventLogger.getEventInfo(e);

        let activityData = new ActivityData(event_name, event_time, event_info);

        //  DEBUG
        // if (["idlestart", "idleend"].includes(event_name)) {
        //     console.log(`${event_name} event fired! Time: ${event_time}`);

        //     if (event_name == "idleend") {
        //         console.log(`Idle duration: ${e.detail.duration}`);
        //     }
        // }
        //  DEBUG

        //  3.  Log e in activity_burst.
        this.activity_burst.addActivityData(activityData);

        //  4.  Attempt to write activity burst to localStorage (if unset in
        //      localStorage).
        this.writeActivityBurstToLocalStorage();
    }

    static getErrorEventInfo(e) {
        return {
            message: event.message,
            filename: event.filename,
            lineno: event.lineno,
            colno: event.colno,
            error: event.error
        };
    }

    static getMouseCoordinates(e) {
        return {
            clientX: e.clientX,
            clientY: e.clientY
        };
    }

    static identifyMouseButton(button_index) {
        //  Identify the mouse button based on its button_index in a mouse
        //  event.
        switch (button_index) {
            case 0:
                return "left";
            case 1:
                return "middle";
            case 2:
                return "right";
            default:
                return "unknown";
        }
    }

    static identifyTarget(target) {
        return {
            id: target.id,
            className: target.className,
            nodeName: target.nodeName
        };
    }

    static getMouseEventInfo(e) {
        return {
            coordinates: ActivityEventLogger.getMouseCoordinates(e),
            button: ActivityEventLogger.identifyMouseButton(e.button),
            target: ActivityEventLogger.identifyTarget(e.target)
        };
    }

    static getScrollEventInfo(e) {
        return {
            target: ActivityEventLogger.identifyTarget(e.target),
            scrollCoordinates: {
                scrollWidth: e.target.scrollingElement.scrollWidth,
                scrollHeight: e.target.scrollingElement.scrollHeight,
                scrollLeft: e.target.scrollingElement.scrollLeft,
                scrollTop: e.target.scrollingElement.scrollTop
            }
        };
    }

    static getKeyEventInfo(e) {
        return {
            key: e.key
        };
    }

    static getVisibilityChangeEventInfo(e) {
        let userEnteredPage = document.visibilityState == "visible";
        return {
            userAction: userEnteredPage ? "Entered Page" : "Exited Page",
            page: document.URL
        };
    }

    static getConsoleErrorEventInfo(e) {
        return {
            arguments: e.detail.arguments
        };
    }

    static getIdleEndEventInfo(e) {
        return {
            idle_duration: e.detail.duration
        };
    }

    static getEventInfo(e) {
        console.log("getActivityFromEvent()");

        if (!e) return {};

        switch (e.type) {
            case "error":
                return ActivityEventLogger.getErrorEventInfo(e);
            case "click":
            case "contextmenu":
            case "dblclick":
            case "mousedown":
            case "mouseup":
            case "mouseenter":
            case "mouseleave":
            case "mouseout":
            case "mouseover":
            case "mousemove":
                return ActivityEventLogger.getMouseEventInfo(e);
            case "scroll":
                return ActivityEventLogger.getScrollEventInfo(e);
            case "keydown":
            case "keypress":
            case "keyup":
                return ActivityEventLogger.getKeyEventInfo(e);
            case "visibilitychange":
                return ActivityEventLogger.getVisibilityChangeEventInfo(e);
            case "console_error":
                return ActivityEventLogger.getConsoleErrorEventInfo(e);
            case "idleend":
                return ActivityEventLogger.getIdleEndEventInfo(e);
            default:
                return {};
        }
    }

    writeActivityBurstToLocalStorage() {
        console.log("writeActivityBurstToLocalStorage().");
        if (!localStorage.getItem(ls_ACTIVITY_BURST) 
            && this.activity_burst.activity.length > 0) {
            console.log("Writing activity burst to localStorage...");
            //  1.  Stringify activity_burst and store it in localStorage.
            localStorage.setItem(ls_ACTIVITY_BURST, 
                JSON.stringify(this.activity_burst));
            
            //  2.  Reset activity_burst in memory.
            this.activity_burst = new ActivityBurst();
        }
    }
}

/*  Global Variables    */

//  Overwrite console to track console errors
// (from https://stackoverflow.com/questions/8000009/is-there-a-way-in-javascript-to-listen-console-events)
let _log = console.log, _warn = console.warn, _error = console.error;

console.log = function() {
    return _log.apply(console, arguments);
}

console.warn = function() {
    return _warn.apply(console, arguments);
}

console.error = function() {
    //  Trigger console_error event
    document.dispatchEvent(new CustomEvent("console_error", {
        detail: {
            arguments: arguments
        }
    }));

    return _error.apply(console, arguments);
}

/*  Function Definitions    */

/**
 * Generate a random user or session ID string of the given length.
 * @param {Number} id_length 
 */
function generateID(id_length) {
    let id = "";
    for (let i = 0; i < ID_LENGTH; i++) {
        let rIndex = Math.floor(Math.random() * ID_ALPHABET_SIZE);

        if (rIndex < NUM_LETTERS) {
            //  Append lower-case letter
            id += String.fromCharCode("a".charCodeAt(0) + rIndex);
        }
        else if (rIndex < NUM_LETTERS * 2) {
            //  Append upper-case letter
            id += String.fromCharCode("A".charCodeAt(0) + rIndex - NUM_LETTERS);
        }
        else {
            //  Append digit
            id += String.fromCharCode("0".charCodeAt(0) 
                + rIndex - (2 * NUM_LETTERS));
        }
    }

    return id;
}

/**
 * Creates new user session.
 * @note This function overrides the session_id, user_session, and session_start
 * key-value pairs in localStorage.
 * @note This function assumes that the user_id key-value pair is already set in
 * localStorage.
 */
function createUserSession() {
    console.log("createUserSession()");

    //  1.  Generate a new session_id and store it in localStorage.
    let session_id = generateID();

    console.log(`Creating new user session with id ${session_id} in `
        + `localStorage.`);
    localStorage.setItem(ls_SESSION_ID, session_id);

    //  2.  Set session_start to the current time in localStorage.
    let session_start = new Date();
    localStorage.setItem(ls_SESSION_START, session_start.toUTCString());

    //  3.  Create a new UserSession object and fill it with static and 
    //      performance data.
    let user_id = localStorage.getItem(ls_USER_ID);
    let user_session = new UserSession(session_id, user_id);

    //  4.  Store the UserSession object in localStorage as a stringified JSON.
    localStorage.setItem(ls_USER_SESSION, JSON.stringify(user_session));
}

async function sendUserSessionObject() {
    console.log("sendUserSessionObject()");

    //  1.  If user_session is set in localStorage:
    let user_session_string = localStorage.getItem(ls_USER_SESSION);
    if (user_session_string) {
        console.log("Attempting to send UserSession object...");

        //  1.  Send the stringified JSON of the UserSession object in
        //      localStorage to USER_SESSION_ENDPOINT with a POST request.
        //  2.  If the request succeeds, unset user_session in localStorage.
        const response = await fetch(USER_SESSION_ENDPOINT, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: user_session_string
        });

        if (response.ok) {
            console.log("Sending UserSession object succeeded, clearing it from"
                + " localStorage");
            
            localStorage.removeItem(ls_USER_SESSION);
        }
        else {
            console.error(`Sending UserSession object failed: received response`
                + ` code ${response.status}.`);
        }
    }
}

async function sendActivityBurstObject(activity_event_logger) {
    console.log("sendActivityBurstObject()");

    //  1.  Try to write activity_burst from memory into localStorage if the
    //      activity_burst in localStorage is unset.
    //      (Ensures activity burst is written to localStorage in this activity
    //      collection period without needing to wait for another event to fire)
    activity_event_logger.writeActivityBurstToLocalStorage();

    //  2.  If the activity_burst is set in localStorage:
    let activity_burst_string = localStorage.getItem(ls_ACTIVITY_BURST);
    if (activity_burst_string) {
        console.log("Attempting to send ActivityBurst object...");

        //  1.  Send the stringified JSON of the ActivityBurst object in
        //      localStorage to ACTIVITY_BURST_ENDPOINT with a POST request.
        //  2.  If the request succeeds, unset activity_burst in localStorage.
        const response = await fetch(ACTIVITY_BURST_ENDPOINT, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: activity_burst_string
        });

        if (response.ok) {
            console.log("Sending ActivityBurst object succeeded, clearing it"
                + " from localStorage.");
            
                localStorage.removeItem(ls_ACTIVITY_BURST);
        }
        else {
            console.error(`Sending ActivityBurst object failed: received`
                + ` response code ${response.status}.`);
        }
    }
}

function loadEventHandler() {
    console.log("loadEventHandler()");

    //  1.  User and Session ID setup.
    //  NOTE: This is only for checkpoint 1. This logic will be removed and
    //  replaced with server-assigned user ID and session ID cookies for
    //  checkpoint 2 onwards.
    //      1.  Determine whether a user already exists; if not, generate a new
    //          ID and a new user session.
    if (!localStorage.getItem(ls_USER_ID)) {
        console.log("Unknown user - creating a new user ID.");

        let user_id = generateID();

        console.log(`Storing user ID ${user_id} in localStorage.`);
        localStorage.setItem(ls_USER_ID, user_id);

        console.log("Creating a new session for the user.");
        createUserSession();
    }
    else {
        //  2.  The user does exist - determine whether a user session already
        //      exists.
        console.log(
            `User is known with ID ${localStorage.getItem(ls_USER_ID)}.`
        );

        //  Get user session ID (if it exists)
        let session_id = localStorage.getItem(ls_SESSION_ID);

        if (!session_id) {
            //  1.  A user session does not exist - create one.
            console.log("A user session does not exist - creating one.");

            createUserSession();
        }
        else {
            //  2.  A user session does exist.
            console.log(`User session does exist with session id `
                + `${session_id}.`
            );

            //      1.  Setup ActivityEventLogger for old session (without
            //          setting up events or idle tracking).
            let activity_event_logger = new ActivityEventLogger(false);
            
            //      2.  Send any unsent data of the previous user session.
            console.log(`Sending any unset data of session ${session_id}.`);
            try {
                sendUserSessionObject();
                sendActivityBurstObject(activity_event_logger);
            } catch (error) {
                console.error(error);
            }

            //      3.  If the user session has expired, create a new user
            //          session.
            let session_start =
                Date.parse(localStorage.getItem(ls_SESSION_START));
            let current_time = new Date();
            
            if (isNaN(session_start)
                || Math.abs(current_time - session_start) > MAX_SESSION_TIME) {
                console.log("Past session is either invalid or expired - "
                    + "creating new session.");

                createUserSession();
            }
        }
    }

    //  2.  Setup ActivityEventLogger (if necessary).
    let activity_event_logger = new ActivityEventLogger();

    //  3.  Send current UserSession data to the server.
    console.log("Sending current user session data (if necessary).");

    try {
        sendUserSessionObject();
    } catch(error) {
        console.error(error);
    }

    //  4.  Setup sending UserSession and ActivityBurst data to the server every
    //      ACTIVITY_COLLECTION_PERIOD seconds.
    setInterval(() => {
        console.log(`Sending data to server (every `
                    + `${ACTIVITY_COLLECTION_PERIOD} milliseconds).`);
        try {
            sendUserSessionObject();
            sendActivityBurstObject(activity_event_logger);
        } catch (error) {
            console.log(error);
        }
    }, ACTIVITY_COLLECTION_PERIOD);
}

/*  Set-up  */

//  Page load handler
addEventListener("load", (event) => {
    console.log("Page load event has fired.");

    //  Wait for page load event to complete so that
    //  window.performance.timing.loadEventEnd is set.
    setTimeout(() => {
        console.log("Page load event has completed.");

        loadEventHandler();
    }, 0);
});