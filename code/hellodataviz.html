<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello Data Visualization</title>
    <script src="https://cdn.zingchart.com/zingchart.min.js"></script>
</head>
<body>
    <div id="sessions-visitors-and-errors"></div>
    <div id="accesses-and-entry-points"></div>
    <div id="language-pie"></div>
    <script>
        function generateTimeScaleText(numDays) {
            let scaleText = [];
            for (let i = 0; i < numDays; i++) {
                if (i == numDays - 1) {
                    scaleText.push('Today');
                } else if (i == numDays - 2) {
                    scaleText.push('Yesterday');
                } 
                else {
                    scaleText.push(`${numDays - 1 - i} ds ago`);
                }
            }

            return scaleText;
        }

        function getDayAgoIndexFromTimestamp(numDays, time_stamp) {
            let time = new Date(time_stamp);
            let time_diff = Date.now() - time;

            //  Convert time_diff in milliseconds to discrete days
            let day_diff = Math.floor(time_diff / (1000 * 60 * 60 * 24));

            return numDays - 1 - day_diff;
        }

        function removeIndexHTML(url_path) {
            let index = url_path.indexOf("index.html");
            if (index < 0) {
                return url_path;
            }
            return url_path.substring(0, index);
        }

        function renderLineChart(activity, sessionArray) {
            console.log("renderLineChart()");

            //  Line chart specification
            //  Answer the following questions:
            //  1.  How many errors have occurred on the site?
            //      *   Further question can then be: On what pages do we see
            //          the errors? (This will require a separate chart, perhaps
            //          a bar chart could be appropriate or a pie chart showing
            //          the breakdown of errors per page)
            //  2.  How many user sessions have there been?
            //  3.  How many unique users have visited the site?
            //  To answer these 3 questions, we'll use a line-chart with three
            //  series.
            //  x-axis: Time (discrete, unit = 1 day)
            //  y-axis: # of occurrences (per unit of time (day))
            //  Three series:
            //      1.  # of errors / day (red)
            //      2.  # of unique visitors / day (green)
            //      3.  # of sessions / day (blue)
            //  The charting of errors / day with sessions and unique visitors
            //  implies a correlation, the expectation of course being that, if
            //  some pages are buggy and have errors, we should expect these
            //  errors to occur (and be logged) more often if those pages have
            //  more visitors, ergo we expect a more-or-less proportional
            //  relationship between errors and visits.
            //  Depending on how error data is collected (e.g., if it were setup
            //  to include server-side error data), we could potentially see
            //  errors spiking *without* an increase / change in visits, which
            //  could imply suspicious behavior (e.g., errors caused by visiting
            //  bots). (However, all error data is collected at present by the
            //  client-side collector.js script, so we won't see that sort of
            //  behavior).

            //  We'll examine the data on a 1-month timescale (30 days, so 29
            //  days ago to today).
            let numDays = 30;
            let scaleText = generateTimeScaleText(numDays);

            //  Fill arrays of data for each of the 3 series.
            let errors = Array(numDays).fill(0);
            let visitors = Array(numDays).fill(0);
            let sessions = Array(numDays).fill(0);

            //  1.  Fill errors series data
            //      1.  For every ActivityBurst burst in the activity array:
            //          1.  For every ActivityData activityData in burst:
            //              1.  If activityData represents an error:
            //                  1.  Determine the day when the activityData
            //                      occurred (as an index in the errors array).
            //                  2.  Increment errors[index] (or set it to 1 if
            //                      it is null).
            for (let activityBurst of activity) {
                for (let activityData of activityBurst.activity) {
                    if (activityData.event_name.includes('error')) {
                        //  Found an error activity event!
                        console.log("Found error!");
                        console.log(activityData);

                        //  Get activityData day
                        let day_index = getDayAgoIndexFromTimestamp(numDays, 
                            activityData.time_stamp);
                        
                        errors[day_index] = 
                            (error[day_index] == null) ? 1 : errors[day_index] + 1;
                    }
                }
            }

            //  2.  Fill visitors and sessions series data
            //      1.  Create an array of length numDays of sets of userIDs
            //          called uniqueVisitors.
            //      2.  For each session:
            //          1.  Determine the day it occurred (and store it in day).
            //          2.  sessions[day]++.
            //          3.  If userID of the session doesn't exist in
            //              uniqueVisitors, add it.
            //      3.  For i = 0 to numDays - 1:
            //          1.  visitors[i] = uniqueVisitors[i].size().
            let uniqueVisitors = Array(numDays).fill(null);

            for (let session of sessionArray) {
                let day_index = getDayAgoIndexFromTimestamp(numDays, 
                    session.performance_data['page-load-end']);

                sessions[day_index] =
                    (sessions[day_index] == null) ? 1 : sessions[day_index] + 1;

                if (uniqueVisitors[day_index] == null) {
                    uniqueVisitors[day_index] = new Set();
                }
                uniqueVisitors[day_index].add(session.user_id);
            }

            for (let i = 0; i < numDays; i++) {
                if (uniqueVisitors[i] != null) {
                    visitors[i] = uniqueVisitors[i].size;
                }
            }

            //  3.  Render line chart
            let lineConfig = {
                theme: 'dark',
                type: 'line',
                title: {
                    text: 'Sessions, Visitors, and Errors',
                    fontSize: 24
                },
                legend: {
                    draggable: true
                },
                scaleX: {
                    label: {text: 'Days'},
                    labels: scaleText
                },
                scaleY: {
                    step: 1
                },
                series: [
                    {
                        values: errors,
                        text: '# Errors',
                        lineColor: "darkred",
                        marker: {
                            size: 7,
                            backgroundColor: 'red',
                            borderColor: 'darkred',
                            borderWidth: '1px'
                        }
                    },
                    {
                        values: visitors,
                        text: '# Visitors',
                        lineColor: "darkgreen",
                        marker: {
                            size: 7,
                            backgroundColor: 'green',
                            borderColor: 'darkgreen',
                            borderWidth: '1px'
                        }
                    },
                    {
                        values: sessions,
                        text: '# Sessions (Visits)',
                        lineColor: "lightblue",
                        marker: {
                            size: 7,
                            backgroundColor: 'DeepSkyBlue',
                            borderColor: 'lightblue',
                            borderWidth: '1px'
                        }
                    }
                ]
            }
            
            zingchart.render({
                id: 'sessions-visitors-and-errors',
                data: lineConfig
            });
        }

        function renderBarChart(activity, sessionArray) {
            console.log('renderBarChart()');

            //  Bar chart specification
            //  Answer the following questions:
            //  1.  Which pages get accessed, and which are the most commonly
            //      accessed pages?
            //  2.  Which pages are entry points, and which are the most common
            //      entry points?
            //  To answer these two questions, we shall use a bar chart with two
            //  series.
            //  x-axis: pages in the site that have been accessed (labeled by
            //          URL)
            //  y-axis: # of occurrences (over the time period of queried data)
            //  Two series:
            //      1.  # of accesses (counted by visibilitychange events)
            //      2.  # of accesses as an entry point (counted by UserSession
            //          URLs)

            //  1.  Create an object of key-value pairs where the key is the URL
            //      and the value is an object with properties for
            //      numAccesses and numEntryPointAccesses.
            let pageAccesses = {};

            for (let session of sessionArray) {
                let url = removeIndexHTML(session.static_data['entry-point']);

                if (url in pageAccesses) {
                    pageAccesses[url].numEntryPointAccesses++;
                }
                else {
                    //  Note: The reason numAccesses is counted as 0 here and
                    //  not as 1 is to avoid double counting, since when a page
                    //  is opened, the entry point access is counted by the
                    //  UserSessions.static_data["entry-point"] property while
                    //  the access is also counted by a visibilitychange event.
                    //  We shall count the visibilitychange event in a separate
                    //  for loop (when we loop over ActivityData objects)
                    pageAccesses[url] = {
                        numAccesses: 0,
                        numEntryPointAccesses: 1
                    };
                }
            }

            for (let activityBurst of activity) {
                for (let activityData of activityBurst.activity) {
                    if (activityData.event_name.includes("visibilitychange")) {
                        let event_info = activityData.event_info;

                        if (event_info.userAction.includes("Entered Page")) {
                            console.log("Found access!");

                            let url = activityData.page;

                            console.log(`Access for ${url}.`);

                            if (url in pageAccesses) {
                                pageAccesses[url].numAccesses++;
                            }
                            else {
                                pageAccesses[url] = {
                                    numAccesses: 1,
                                    numEntryPointAccesses: 0
                                };
                            }
                        }
                    }
                }
            }

            //  x-axis
            let pages = [];

            //  y-axis data (2-series)
            let numAccesses = [];
            let numEntryPointAccesses = [];

            //  Page object array (for sorting)
            let pageObjects = [];

            for (const url in pageAccesses) {
                pageObjects.push({
                    url: url,
                    numAccesses: pageAccesses[url].numAccesses,
                    numEntryPointAccesses: 
                        pageAccesses[url].numEntryPointAccesses
                });
            }

            //  Sort pageObjects by numEntryPointAccesses, then by numAccesses
            pageObjects.sort((p1, p2) => {
                let numEntryPointAccessesDiff = p2.numEntryPointAccesses 
                    - p1.numEntryPointAccesses;

                if (numEntryPointAccessesDiff != 0)
                    return numEntryPointAccessesDiff;
            
                return p2.numAccesses - p1.numAccesses;
            });

            //  Create x-axis and y-axis data
            for (let page of pageObjects) {
                pages.push(page.url);
                numAccesses.push(page.numAccesses);
                numEntryPointAccesses.push(page.numEntryPointAccesses);
            }

            let barConfig = {
                type: 'bar',
                title: {
                    text: 'Page Accesses and Entry Points',
                    fontSize: 24
                },
                legend: {
                    draggable: true
                },
                scaleX: {
                    label: {text: 'Page URLs'},
                    labels: pages
                },
                scaleY: {
                    step: 1
                },
                series: [
                    {
                        values: numAccesses,
                        text: '# Accesses',
                        tooltip: {
                            text: "%kt accessed %vt times."
                        }
                    },
                    {
                        values: numEntryPointAccesses,
                        text: '# Entry Point Accesses',
                        tooltip: {
                            text: "%kt accessed as entry point %vt times."
                        }
                    }
                ]
            };

            zingchart.render({
                id: 'accesses-and-entry-points',
                data: barConfig
            });
        }

        function renderPieChart(sessionArray) {
            console.log('renderPieChart()');

            //  Pie chart specification
            //  Answer the following question:
            //  1.  What is the language breakdown of users that visit the site?
            //  To answer this question, we shall use a pie chart.
            //      Each slice in the pie-chart will represent a language and
            //      the size of the slice will represent the percentage of user
            //      sessions with that language as compared with all user
            //      sessions.
            
            let numUserSessions = sessionArray.length;
            let languages = {};

            for (let session of sessionArray) {
                let language = session.static_data['user-language'];

                if (language in languages) {
                    languages[language].numSessions++;
                }
                else {
                    languages[language] = { numSessions: 1};
                }
            }

            let series = [];

            for (let language in languages) {
                series.push({
                    text: language,
                    values: [languages[language].numSessions / numUserSessions]
                });
            }

            let pieConfig = {
                type: "pie",
                title: {
                    text: "Session Languages",
                    fontSize: 24
                },
                plot: {
                    fontColor: "black"
                },
                legend: {
                    draggable: true
                },
                series: series
            };

            zingchart.render({
                id: 'language-pie',
                data: pieConfig
            });
        }

        addEventListener('load', async (e) => {
            //  1.  Query UserSessions and ActivityBurst data.
            //  Note: Here, we're pulling *all* data from the database.
            //  This is fine when the database is sufficiently small, but
            //  eventually this may become unfeasible.
            //  When this occurs, instead of pulling the data from the database
            //  and modifying it to produce the ZingChart config objects to
            //  display the data, this work should be moved to the server-side
            //  and the client just needs to fetch the config JSON objects from
            //  the server (e.g., by sending a GET request to
            //  /api/hello-data-visualization)
            //  Additionally, assuming the database grew such that the time
            //  period of the data grows (e.g., to a month, a year, etc.), it
            //  would make sense to modify this so that instead of fetching all
            //  of the data, we'd only fetch data that is recent (e.g., with
            //  timestamps within the last day / week / month) to make the
            //  amount of handled data more reasonable.

            let response = await fetch('https://gilkeidar.com/api/user-sessions');
            let sessionArray = await response.json();

            response = await fetch('https://gilkeidar.com/api/activity-bursts');
            let activity = await response.json();

            //  2.  Render the queried data in the specified charts
            renderLineChart(activity, sessionArray);
            renderBarChart(activity, sessionArray);
            renderPieChart(sessionArray);
        })

    </script>
</body>
</html>